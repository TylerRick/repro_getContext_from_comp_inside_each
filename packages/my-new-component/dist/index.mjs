import { SvelteComponent, init, safe_not_equal, text, insert, noop, detach, create_slot, element, space, listen, update_slot, transition_in, transition_out } from 'svelte/internal';
import { setContext, getContext } from 'svelte';

/* src/Component.svelte generated by Svelte v3.29.0 */

function create_fragment(ctx) {
	let t;

	return {
		c() {
			t = text("my-new-component");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

/* src/FieldArray.svelte generated by Svelte v3.29.0 */

const get_default_slot_changes = dirty => ({ names: dirty & /*names*/ 1 });
const get_default_slot_context = ctx => ({ names: /*names*/ ctx[0] });

function create_fragment$1(ctx) {
	let button;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context);

	return {
		c() {
			button = element("button");
			button.textContent = "Blow up";
			t1 = space();
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			insert(target, button, anchor);
			insert(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*handleClick*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, names*/ 5) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	console.log("my-new-component FieldArray");
	let names = ["a"];

	const handleClick = () => {
		console.log("changing names to [a, b] from event callback");
		$$invalidate(0, names = ["a", "b"]);
	};

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [names, handleClick, $$scope, slots];
}

class FieldArray extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment$1, safe_not_equal, {});
	}
}

/* src/UsesContext.svelte generated by Svelte v3.29.0 */

function create_fragment$2(ctx) {
	let t;

	return {
		c() {
			t = text(/*context*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function instance$1($$self) {
	console.log("my-new-component UsesContext");

	// Using onMount also causes the same error:
	// import { onDestroy, onMount } from "svelte";
	// onMount(() => {
	//   console.log('UsesContext: onMount')
	// });
	const key = {};

	setContext(key, "context");
	let context = getContext(key);
	return [context];
}

class UsesContext extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$2, safe_not_equal, {});
	}
}

export { FieldArray, Component as NewComp, UsesContext };
